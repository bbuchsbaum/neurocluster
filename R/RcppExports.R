# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

correlation_gradient_cpp <- function(img_4d, brain_mask) {
    .Call('_neurocluster_correlation_gradient_cpp', PACKAGE = 'neurocluster', img_4d, brain_mask)
}

compute_scores <- function(curclus, coords, data_centroids, coord_centroids, data, sigma1, sigma2) {
    .Call('_neurocluster_compute_scores', PACKAGE = 'neurocluster', curclus, coords, data_centroids, coord_centroids, data, sigma1, sigma2)
}

best_candidate <- function(candidates, curclus, coords, data_centroids, coord_centroids, data, sigma1, sigma2, alpha) {
    .Call('_neurocluster_best_candidate', PACKAGE = 'neurocluster', candidates, curclus, coords, data_centroids, coord_centroids, data, sigma1, sigma2, alpha)
}

find_candidates <- function(nn_index, nn_dist, curclus, dthresh) {
    .Call('_neurocluster_find_candidates', PACKAGE = 'neurocluster', nn_index, nn_dist, curclus, dthresh)
}

best_candidate_parallel <- function(candidates, curclus, coords, data_centroids, coord_centroids, data, sigma1, sigma2, alpha, grain_size = 100L) {
    .Call('_neurocluster_best_candidate_parallel', PACKAGE = 'neurocluster', candidates, curclus, coords, data_centroids, coord_centroids, data, sigma1, sigma2, alpha, grain_size)
}

best_candidate_sequential <- function(candidates, curclus, coords, data_centroids, coord_centroids, data, sigma1, sigma2, alpha) {
    .Call('_neurocluster_best_candidate_sequential', PACKAGE = 'neurocluster', candidates, curclus, coords, data_centroids, coord_centroids, data, sigma1, sigma2, alpha)
}

heat_kernel <- function(x1, x2, sigma) {
    .Call('_neurocluster_heat_kernel', PACKAGE = 'neurocluster', x1, x2, sigma)
}

normalized_heat_kernel <- function(x1, x2, sigma) {
    .Call('_neurocluster_normalized_heat_kernel', PACKAGE = 'neurocluster', x1, x2, sigma)
}

fused_assignment <- function(nn_index, nn_dist, curclus, coords, data_centroids, coord_centroids, data, dthresh, sigma1, sigma2, alpha) {
    .Call('_neurocluster_fused_assignment', PACKAGE = 'neurocluster', nn_index, nn_dist, curclus, coords, data_centroids, coord_centroids, data, dthresh, sigma1, sigma2, alpha)
}

fused_assignment_parallel <- function(nn_index, nn_dist, curclus, coords, data_centroids, coord_centroids, data, dthresh, sigma1, sigma2, alpha, grain_size = 100L) {
    .Call('_neurocluster_fused_assignment_parallel', PACKAGE = 'neurocluster', nn_index, nn_dist, curclus, coords, data_centroids, coord_centroids, data, dthresh, sigma1, sigma2, alpha, grain_size)
}

compute_centroids_parallel <- function(cluster_ids, data, coords, n_clusters, grain_size = 10L) {
    .Call('_neurocluster_compute_centroids_parallel', PACKAGE = 'neurocluster', cluster_ids, data, coords, n_clusters, grain_size)
}

slice_msf_runwise <- function(TS, mask, vol_dim, r = 12L, fh_scale = 0.32, min_size = 80L, nbhd = 8L, stitch_z = FALSE, theta_link = 0.85, min_contact = 1L, rows_are_time = TRUE, gamma = 1.5, voxel_dim = NULL, spatial_beta = 0.0, target_k_global = -1L, target_k_per_slice = -1L) {
    .Call('_neurocluster_slice_msf_runwise', PACKAGE = 'neurocluster', TS, mask, vol_dim, r, fh_scale, min_size, nbhd, stitch_z, theta_link, min_contact, rows_are_time, gamma, voxel_dim, spatial_beta, target_k_global, target_k_per_slice)
}

slice_fuse_consensus <- function(run_results, vol_dim, nbhd = 8L, fh_scale = 0.30, min_size = 80L, use_features = FALSE, lambda = 0.7, voxel_dim = NULL, spatial_beta = 0.0, target_k_global = -1L, target_k_per_slice = -1L, stitch_z = FALSE) {
    .Call('_neurocluster_slice_fuse_consensus', PACKAGE = 'neurocluster', run_results, vol_dim, nbhd, fh_scale, min_size, use_features, lambda, voxel_dim, spatial_beta, target_k_global, target_k_per_slice, stitch_z)
}

update_centroid_online <- function(centroid, x_i, c_i) {
    .Call('_neurocluster_update_centroid_online', PACKAGE = 'neurocluster', centroid, x_i, c_i)
}

snic_main <- function(L_data, mask, centroids, centroid_idx, valid_coords, norm_coords, vecmat, K, s, compactness, mask_lookup_data) {
    .Call('_neurocluster_snic_main', PACKAGE = 'neurocluster', L_data, mask, centroids, centroid_idx, valid_coords, norm_coords, vecmat, K, s, compactness, mask_lookup_data)
}

compute_boundaryscore_3d_cpp <- function(volume, mask) {
    .Call('_neurocluster_compute_boundaryscore_3d_cpp', PACKAGE = 'neurocluster', volume, mask)
}

detect_boundaries_2d_cpp <- function(volume, mask) {
    .Call('_neurocluster_detect_boundaries_2d_cpp', PACKAGE = 'neurocluster', volume, mask)
}

