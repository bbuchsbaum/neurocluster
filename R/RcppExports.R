# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Refine boundary voxels using C++ acceleration
#'
#' @param voxel_labels Integer vector of current cluster assignments (0-based internally)
#' @param feature_mat_normalized Numeric matrix (voxels x time) with NORMALIZED features
#' @param neighbor_indices Integer matrix (voxels x K) of nearest neighbor indices (1-based from R)
#' @param boundary_voxels Integer vector of boundary voxel indices (1-based from R)
#' @param max_iter Maximum number of refinement iterations
#'
#' @return List containing updated labels and number of iterations performed
#'
#' @keywords internal
refine_boundaries_cpp <- function(voxel_labels, feature_mat_normalized, neighbor_indices, boundary_voxels, max_iter = 5L) {
    .Call('_neurocluster_refine_boundaries_cpp', PACKAGE = 'neurocluster', voxel_labels, feature_mat_normalized, neighbor_indices, boundary_voxels, max_iter)
}

#' Find boundary voxels (voxels with neighbors having different labels)
#'
#' @param voxel_labels Integer vector of cluster assignments
#' @param neighbor_indices Integer matrix (voxels x K) of nearest neighbor indices (1-based)
#'
#' @return Integer vector of boundary voxel indices (1-based for R)
#'
#' @keywords internal
find_boundary_voxels_cpp <- function(voxel_labels, neighbor_indices) {
    .Call('_neurocluster_find_boundary_voxels_cpp', PACKAGE = 'neurocluster', voxel_labels, neighbor_indices)
}

compute_centroids_parallel_fast <- function(cluster_ids, data, coords, n_clusters) {
    .Call('_neurocluster_compute_centroids_parallel_fast', PACKAGE = 'neurocluster', cluster_ids, data, coords, n_clusters)
}

correlation_gradient_cpp <- function(img_4d, brain_mask) {
    .Call('_neurocluster_correlation_gradient_cpp', PACKAGE = 'neurocluster', img_4d, brain_mask)
}

build_grid_adjacency_cpp <- function(mask_idx, dims, connectivity) {
    .Call('_neurocluster_build_grid_adjacency_cpp', PACKAGE = 'neurocluster', mask_idx, dims, connectivity)
}

rena_rnn_coarse_cpp <- function(X, G, grad_img, stop_at, lambda = 0.0, max_iter = 100L) {
    .Call('_neurocluster_rena_rnn_coarse_cpp', PACKAGE = 'neurocluster', X, G, grad_img, stop_at, lambda, max_iter)
}

ward_on_supervoxels_cpp <- function(X_coarse, G_coarse, sizes, n_clusters) {
    .Call('_neurocluster_ward_on_supervoxels_cpp', PACKAGE = 'neurocluster', X_coarse, G_coarse, sizes, n_clusters)
}

compute_scores <- function(curclus, coords, data_centroids, coord_centroids, data, sigma1, sigma2) {
    .Call('_neurocluster_compute_scores', PACKAGE = 'neurocluster', curclus, coords, data_centroids, coord_centroids, data, sigma1, sigma2)
}

best_candidate <- function(candidates, curclus, coords, data_centroids, coord_centroids, data, sigma1, sigma2, alpha) {
    .Call('_neurocluster_best_candidate', PACKAGE = 'neurocluster', candidates, curclus, coords, data_centroids, coord_centroids, data, sigma1, sigma2, alpha)
}

find_candidates <- function(nn_index, nn_dist, curclus, dthresh) {
    .Call('_neurocluster_find_candidates', PACKAGE = 'neurocluster', nn_index, nn_dist, curclus, dthresh)
}

best_candidate_parallel <- function(candidates, curclus, coords, data_centroids, coord_centroids, data, sigma1, sigma2, alpha, grain_size = 100L) {
    .Call('_neurocluster_best_candidate_parallel', PACKAGE = 'neurocluster', candidates, curclus, coords, data_centroids, coord_centroids, data, sigma1, sigma2, alpha, grain_size)
}

best_candidate_sequential <- function(candidates, curclus, coords, data_centroids, coord_centroids, data, sigma1, sigma2, alpha) {
    .Call('_neurocluster_best_candidate_sequential', PACKAGE = 'neurocluster', candidates, curclus, coords, data_centroids, coord_centroids, data, sigma1, sigma2, alpha)
}

heat_kernel <- function(x1, x2, sigma) {
    .Call('_neurocluster_heat_kernel', PACKAGE = 'neurocluster', x1, x2, sigma)
}

normalized_heat_kernel <- function(x1, x2, sigma) {
    .Call('_neurocluster_normalized_heat_kernel', PACKAGE = 'neurocluster', x1, x2, sigma)
}

flash3d_supervoxels_cpp <- function(ts, mask_lin0, dims, K, lambda, rounds = 2L, bits = 64L, dctM = 12L, vox_scale = as.numeric( c(1.0,1.0,1.0)), barrier_opt = NULL, verbose = FALSE) {
    .Call('_neurocluster_flash3d_supervoxels_cpp', PACKAGE = 'neurocluster', ts, mask_lin0, dims, K, lambda, rounds, bits, dctM, vox_scale, barrier_opt, verbose)
}

fused_assignment <- function(nn_index, nn_dist, curclus, coords, data_centroids, coord_centroids, data, dthresh, sigma1, sigma2, alpha) {
    .Call('_neurocluster_fused_assignment', PACKAGE = 'neurocluster', nn_index, nn_dist, curclus, coords, data_centroids, coord_centroids, data, dthresh, sigma1, sigma2, alpha)
}

fused_assignment_parallel <- function(nn_index, nn_dist, curclus, coords, data_centroids, coord_centroids, data, dthresh, sigma1, sigma2, alpha, grain_size = 100L) {
    .Call('_neurocluster_fused_assignment_parallel', PACKAGE = 'neurocluster', nn_index, nn_dist, curclus, coords, data_centroids, coord_centroids, data, dthresh, sigma1, sigma2, alpha, grain_size)
}

compute_centroids_parallel <- function(cluster_ids, data, coords, n_clusters, grain_size = 10L) {
    .Call('_neurocluster_compute_centroids_parallel', PACKAGE = 'neurocluster', cluster_ids, data, coords, n_clusters, grain_size)
}

fused_assignment_parallel_binned <- function(nn_index, nn_dist, curclus, coords, data_centroids, coord_centroids, data, dthresh, sigma1, sigma2, alpha, grain_size = 2048L, window_factor = 2.0, bin_expand = 1L) {
    .Call('_neurocluster_fused_assignment_parallel_binned', PACKAGE = 'neurocluster', nn_index, nn_dist, curclus, coords, data_centroids, coord_centroids, data, dthresh, sigma1, sigma2, alpha, grain_size, window_factor, bin_expand)
}

fused_assignment_binned <- function(nn_index, nn_dist, curclus, coords, data_centroids, coord_centroids, data, dthresh, sigma1, sigma2, alpha, window_factor = 2.0, bin_expand = 1L) {
    .Call('_neurocluster_fused_assignment_binned', PACKAGE = 'neurocluster', nn_index, nn_dist, curclus, coords, data_centroids, coord_centroids, data, dthresh, sigma1, sigma2, alpha, window_factor, bin_expand)
}

calculate_local_gradient <- function(feature_mat, neighbor_indices) {
    .Call('_neurocluster_calculate_local_gradient', PACKAGE = 'neurocluster', feature_mat, neighbor_indices)
}

g3s_propagate_cpp <- function(feature_mat, coords, seed_indices, neighbor_indices, neighbor_dists, alpha, compactness) {
    .Call('_neurocluster_g3s_propagate_cpp', PACKAGE = 'neurocluster', feature_mat, coords, seed_indices, neighbor_indices, neighbor_dists, alpha, compactness)
}

refine_boundaries_g3s_cpp <- function(labels, feature_mat, neighbor_indices, max_iter) {
    .Call('_neurocluster_refine_boundaries_g3s_cpp', PACKAGE = 'neurocluster', labels, feature_mat, neighbor_indices, max_iter)
}

#' Normalize Volumes by Removing Mean Offset (Fast C++ Implementation)
#'
#' Removes the mean offset from each volume/timepoint in a matrix.
#' This centers each volume to have zero mean across voxels.
#'
#' @param data Numeric matrix with voxels as rows and timepoints as columns
#' @return Numeric matrix with each column (volume) centered to mean zero
#'
#' @details
#' For each timepoint t, computes mean_t = mean(data[,t]) and subtracts
#' it from all voxels: output[,t] = data[,t] - mean_t
#'
#' Uses RcppParallel for fast parallel computation across voxels.
#'
#' @export
normalize_volumes_cpp <- function(data) {
    .Call('_neurocluster_normalize_volumes_cpp', PACKAGE = 'neurocluster', data)
}

#' Detrend Voxel Timeseries (Fast C++ Implementation)
#'
#' Removes linear trend from each voxel's timeseries using fast
#' parallel linear regression.
#'
#' @param data Numeric matrix with voxels as rows and timepoints as columns
#' @return Numeric matrix with linear trend removed from each row (voxel)
#'
#' @details
#' For each voxel, fits a linear model y = intercept + slope * t and
#' subtracts the fitted values: residuals = y - fitted.
#'
#' Uses RcppParallel for fast parallel computation across voxels.
#' The linear regression is computed efficiently using precomputed
#' time statistics.
#'
#' @export
detrend_time_cpp <- function(data) {
    .Call('_neurocluster_detrend_time_cpp', PACKAGE = 'neurocluster', data)
}

#' Normalize Volumes and Detrend Timeseries (Fast C++ Implementation)
#'
#' Combined operation: first removes volume mean offsets, then removes
#' linear trend from each voxel's timeseries. More efficient than
#' calling both functions separately.
#'
#' @param data Numeric matrix with voxels as rows and timepoints as columns
#' @return Numeric matrix with volume offsets and linear trends removed
#'
#' @details
#' Performs two operations in a single parallel pass:
#' 1. Centers each volume to zero mean
#' 2. Removes linear trend from each voxel's (now centered) timeseries
#'
#' @export
normalize_detrend_cpp <- function(data) {
    .Call('_neurocluster_normalize_detrend_cpp', PACKAGE = 'neurocluster', data)
}

#' Generate DCT-II Basis Matrix
#'
#' Creates a discrete cosine transform (type II) basis matrix for detrending.
#'
#' @param n_time Number of timepoints
#' @param n_basis Number of DCT basis functions (including constant)
#' @return Numeric matrix (n_time x n_basis) with orthonormal DCT basis
#'
#' @details
#' DCT basis functions are excellent for removing low-frequency drift in fMRI.
#' The first basis is constant (mean), subsequent bases capture increasingly
#' higher frequency components.
#'
#' @export
make_dct_basis <- function(n_time, n_basis) {
    .Call('_neurocluster_make_dct_basis', PACKAGE = 'neurocluster', n_time, n_basis)
}

#' Generate Polynomial Basis Matrix
#'
#' Creates a polynomial basis matrix for detrending.
#'
#' @param n_time Number of timepoints
#' @param degree Polynomial degree (0 = constant, 1 = linear, 2 = quadratic, etc.)
#' @return Numeric matrix (n_time x (degree+1)) with orthonormalized polynomial basis
#'
#' @details
#' Uses Gram-Schmidt orthonormalization for numerical stability.
#' Degree 0 = mean removal, 1 = linear detrend, 2 = quadratic, etc.
#'
#' @export
make_poly_basis <- function(n_time, degree) {
    .Call('_neurocluster_make_poly_basis', PACKAGE = 'neurocluster', n_time, degree)
}

#' Flexible Detrending with Basis Functions (Fast C++ Implementation)
#'
#' Removes trends from each voxel's timeseries by projecting out a basis.
#' Supports polynomial or DCT (discrete cosine transform) basis functions.
#'
#' @param data Numeric matrix with voxels as rows and timepoints as columns
#' @param basis Orthonormal basis matrix (n_time x n_basis) to project out.
#'   Use make_dct_basis() or make_poly_basis() to generate.
#' @return Numeric matrix with basis components removed from each row
#'
#' @details
#' For orthonormal basis B, computes residuals as:
#' y_detrend = y - B * (B^T * y)
#'
#' This is equivalent to regressing out the basis and keeping residuals.
#'
#' @examples
#' \dontrun
#' # Remove linear + quadratic trend (polynomial degree 2)
#' basis <- make_poly_basis(n_time = 100, degree = 2)
#' data_detrend <- detrend_basis_cpp(data, basis)
#'
#' # Remove low-frequency drift with DCT (first 5 components)
#' basis <- make_dct_basis(n_time = 100, n_basis = 5)
#' data_detrend <- detrend_basis_cpp(data, basis)
#' }
#'
#' @export
detrend_basis_cpp <- function(data, basis) {
    .Call('_neurocluster_detrend_basis_cpp', PACKAGE = 'neurocluster', data, basis)
}

#' Polynomial Detrending (Convenience Function)
#'
#' Removes polynomial trend up to specified degree from each voxel.
#'
#' @param data Numeric matrix with voxels as rows and timepoints as columns
#' @param degree Polynomial degree (0 = mean, 1 = linear, 2 = quadratic, etc.)
#' @return Numeric matrix with polynomial trend removed
#'
#' @details
#' Convenience wrapper that generates polynomial basis and calls detrend_basis_cpp.
#' For degree=1, this is equivalent to detrend_time_cpp but slightly slower.
#'
#' @export
detrend_poly_cpp <- function(data, degree = 1L) {
    .Call('_neurocluster_detrend_poly_cpp', PACKAGE = 'neurocluster', data, degree)
}

#' DCT Detrending (Convenience Function)
#'
#' Removes low-frequency components using discrete cosine transform.
#'
#' @param data Numeric matrix with voxels as rows and timepoints as columns
#' @param n_basis Number of DCT basis functions to remove (including constant).
#'   Default 4 removes constant, linear, and first two cosine harmonics.
#' @return Numeric matrix with low-frequency components removed
#'
#' @details
#' DCT detrending is commonly used in fMRI preprocessing. The number of
#' basis functions controls the high-pass filter cutoff:
#' - n_basis = 1: mean removal only
#' - n_basis = 2: ~ linear detrend
#' - n_basis = 4-6: typical for fMRI (removes drift < ~0.01 Hz for TR=2s)
#'
#' Higher n_basis = more aggressive high-pass filtering.
#'
#' @export
detrend_dct_cpp <- function(data, n_basis = 4L) {
    .Call('_neurocluster_detrend_dct_cpp', PACKAGE = 'neurocluster', data, n_basis)
}

#' Compute masked distances for ReNA
#'
#' Computes squared Euclidean distances only for connected pairs in sparse adjacency.
#'
#' @param feature_mat Numeric matrix (features x voxels)
#' @param adjacency_i Integer vector of row indices for sparse adjacency
#' @param adjacency_j Integer vector of col indices for sparse adjacency
#' @return NumericVector of distances (same length as adjacency_i)
#'
#' @keywords internal
compute_masked_distances_cpp <- function(feature_mat, adjacency_i, adjacency_j) {
    .Call('_neurocluster_compute_masked_distances_cpp', PACKAGE = 'neurocluster', feature_mat, adjacency_i, adjacency_j)
}

#' Find 1-Nearest Neighbor subgraph for ReNA
#'
#' For each node, finds its single nearest neighbor to form directed 1-NN graph.
#'
#' @param n_nodes Number of nodes
#' @param adjacency_i Integer vector of row indices for sparse adjacency
#' @param adjacency_j Integer vector of col indices for sparse adjacency
#' @param distances Numeric vector of distances for each edge
#' @return IntegerVector of nearest neighbor indices (0-based, -1 if no neighbors)
#'
#' @keywords internal
find_1nn_subgraph_cpp <- function(n_nodes, adjacency_i, adjacency_j, distances) {
    .Call('_neurocluster_find_1nn_subgraph_cpp', PACKAGE = 'neurocluster', n_nodes, adjacency_i, adjacency_j, distances)
}

#' Find connected components using Union-Find
#'
#' Finds weakly connected components in a directed graph defined by 1-NN edges.
#'
#' @param n_nodes Number of nodes
#' @param nearest_neighbor IntegerVector of nearest neighbor for each node (0-based)
#' @return IntegerVector of component labels (0-based, contiguous)
#'
#' @keywords internal
find_connected_components_cpp <- function(n_nodes, nearest_neighbor) {
    .Call('_neurocluster_find_connected_components_cpp', PACKAGE = 'neurocluster', n_nodes, nearest_neighbor)
}

#' Aggregate features by component (mean pooling)
#'
#' Computes mean feature vector for each component efficiently.
#'
#' @param feature_mat Numeric matrix (features x voxels)
#' @param component_labels IntegerVector of component labels (0-based)
#' @param n_components Number of unique components
#' @return NumericMatrix of aggregated features (features x n_components)
#'
#' @keywords internal
aggregate_features_cpp <- function(feature_mat, component_labels, n_components) {
    .Call('_neurocluster_aggregate_features_cpp', PACKAGE = 'neurocluster', feature_mat, component_labels, n_components)
}

#' Aggregate coordinates by component (mean pooling)
#'
#' Computes mean coordinate for each component efficiently.
#'
#' @param coords Numeric matrix (voxels x 3)
#' @param component_labels IntegerVector of component labels (0-based)
#' @param n_components Number of unique components
#' @return NumericMatrix of aggregated coordinates (n_components x 3)
#'
#' @keywords internal
aggregate_coords_cpp <- function(coords, component_labels, n_components) {
    .Call('_neurocluster_aggregate_coords_cpp', PACKAGE = 'neurocluster', coords, component_labels, n_components)
}

#' Contract adjacency graph by merging components
#'
#' Builds new adjacency matrix where nodes are components and edges exist if
#' any constituent nodes were connected.
#'
#' @param adjacency_i Integer vector of row indices for sparse adjacency
#' @param adjacency_j Integer vector of col indices for sparse adjacency
#' @param component_labels IntegerVector of component labels (0-based)
#' @param n_components Number of unique components
#' @return List with contracted_i and contracted_j vectors
#'
#' @keywords internal
contract_graph_cpp <- function(adjacency_i, adjacency_j, component_labels, n_components) {
    .Call('_neurocluster_contract_graph_cpp', PACKAGE = 'neurocluster', adjacency_i, adjacency_j, component_labels, n_components)
}

#' Prune 1-NN edges to achieve target number of components
#'
#' Sorts 1-NN edges by distance and adds them incrementally until K components remain.
#' Used for exact-K stopping condition.
#'
#' @param n_nodes Number of nodes
#' @param nearest_neighbor IntegerVector of nearest neighbor for each node (0-based)
#' @param distances NumericVector of distances to nearest neighbors
#' @param target_k Target number of components
#' @return IntegerVector of pruned nearest neighbors (-1 for pruned edges)
#'
#' @keywords internal
prune_edges_for_k_cpp <- function(n_nodes, nearest_neighbor, distances, target_k) {
    .Call('_neurocluster_prune_edges_for_k_cpp', PACKAGE = 'neurocluster', n_nodes, nearest_neighbor, distances, target_k)
}

slic4d_core <- function(feats, coords, mask_lin_idx, dims, voxmm, K, compactness = 10.0, max_iter = 10L, step_mm = 0.0, n_threads = 0L, seed_method = "mask_poisson", enforce_connectivity = TRUE, min_size = 0L, connectivity = 26L, strict_connectivity = TRUE, preserve_k = FALSE, topup_iters = 2L, grad_masked = numeric(), seed_relocate_radius = 1L, verbose = FALSE) {
    .Call('_neurocluster_slic4d_core', PACKAGE = 'neurocluster', feats, coords, mask_lin_idx, dims, voxmm, K, compactness, max_iter, step_mm, n_threads, seed_method, enforce_connectivity, min_size, connectivity, strict_connectivity, preserve_k, topup_iters, grad_masked, seed_relocate_radius, verbose)
}

slice_msf_runwise <- function(TS, mask, vol_dim, r = 12L, fh_scale = 0.32, min_size = 80L, nbhd = 8L, stitch_z = FALSE, theta_link = 0.85, min_contact = 1L, rows_are_time = TRUE, gamma = 1.5, voxel_dim = NULL, spatial_beta = 0.0, target_k_global = -1L, target_k_per_slice = -1L, z_mult = 0.0, w_threshold = 0.0) {
    .Call('_neurocluster_slice_msf_runwise', PACKAGE = 'neurocluster', TS, mask, vol_dim, r, fh_scale, min_size, nbhd, stitch_z, theta_link, min_contact, rows_are_time, gamma, voxel_dim, spatial_beta, target_k_global, target_k_per_slice, z_mult, w_threshold)
}

slice_fuse_consensus <- function(run_results, vol_dim, nbhd = 8L, fh_scale = 0.30, min_size = 80L, use_features = FALSE, lambda = 0.7, voxel_dim = NULL, spatial_beta = 0.0, target_k_global = -1L, target_k_per_slice = -1L, stitch_z = FALSE) {
    .Call('_neurocluster_slice_fuse_consensus', PACKAGE = 'neurocluster', run_results, vol_dim, nbhd, fh_scale, min_size, use_features, lambda, voxel_dim, spatial_beta, target_k_global, target_k_per_slice, stitch_z)
}

update_centroid_online <- function(centroid, x_i, c_i) {
    .Call('_neurocluster_update_centroid_online', PACKAGE = 'neurocluster', centroid, x_i, c_i)
}

snic_main <- function(L_data, mask, centroids, centroid_idx, valid_coords, norm_coords, vecmat, K, s, compactness, mask_lookup_data) {
    .Call('_neurocluster_snic_main', PACKAGE = 'neurocluster', L_data, mask, centroids, centroid_idx, valid_coords, norm_coords, vecmat, K, s, compactness, mask_lookup_data)
}

snic_main_optimized <- function(L_data, mask, centroids, centroid_idx, valid_coords, norm_coords, vecmat, K, s, compactness, mask_lookup_data) {
    .Call('_neurocluster_snic_main_optimized', PACKAGE = 'neurocluster', L_data, mask, centroids, centroid_idx, valid_coords, norm_coords, vecmat, K, s, compactness, mask_lookup_data)
}

compute_boundaryscore_3d_cpp <- function(volume, mask) {
    .Call('_neurocluster_compute_boundaryscore_3d_cpp', PACKAGE = 'neurocluster', volume, mask)
}

detect_boundaries_2d_cpp <- function(volume, mask) {
    .Call('_neurocluster_detect_boundaries_2d_cpp', PACKAGE = 'neurocluster', volume, mask)
}

