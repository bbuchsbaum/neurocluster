# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Refine boundary voxels using C++ acceleration
#'
#' @param voxel_labels Integer vector of current cluster assignments (0-based internally)
#' @param feature_mat_normalized Numeric matrix (voxels x time) with NORMALIZED features
#' @param neighbor_indices Integer matrix (voxels x K) of nearest neighbor indices (1-based from R)
#' @param boundary_voxels Integer vector of boundary voxel indices (1-based from R)
#' @param max_iter Maximum number of refinement iterations
#'
#' @return List containing updated labels and number of iterations performed
#'
#' @keywords internal
refine_boundaries_cpp <- function(voxel_labels, feature_mat_normalized, neighbor_indices, boundary_voxels, max_iter = 5L) {
    .Call('_neurocluster_refine_boundaries_cpp', PACKAGE = 'neurocluster', voxel_labels, feature_mat_normalized, neighbor_indices, boundary_voxels, max_iter)
}

#' Find boundary voxels (voxels with neighbors having different labels)
#'
#' @param voxel_labels Integer vector of cluster assignments
#' @param neighbor_indices Integer matrix (voxels x K) of nearest neighbor indices (1-based)
#'
#' @return Integer vector of boundary voxel indices (1-based for R)
#'
#' @keywords internal
find_boundary_voxels_cpp <- function(voxel_labels, neighbor_indices) {
    .Call('_neurocluster_find_boundary_voxels_cpp', PACKAGE = 'neurocluster', voxel_labels, neighbor_indices)
}

compute_centroids_parallel_fast <- function(cluster_ids, data, coords, n_clusters) {
    .Call('_neurocluster_compute_centroids_parallel_fast', PACKAGE = 'neurocluster', cluster_ids, data, coords, n_clusters)
}

correlation_gradient_cpp <- function(img_4d, brain_mask) {
    .Call('_neurocluster_correlation_gradient_cpp', PACKAGE = 'neurocluster', img_4d, brain_mask)
}

build_grid_adjacency_cpp <- function(mask_idx, dims, connectivity) {
    .Call('_neurocluster_build_grid_adjacency_cpp', PACKAGE = 'neurocluster', mask_idx, dims, connectivity)
}

rena_rnn_coarse_cpp <- function(X, G, grad_img, stop_at, lambda = 0.0, max_iter = 100L) {
    .Call('_neurocluster_rena_rnn_coarse_cpp', PACKAGE = 'neurocluster', X, G, grad_img, stop_at, lambda, max_iter)
}

ward_on_supervoxels_cpp <- function(X_coarse, G_coarse, sizes, n_clusters) {
    .Call('_neurocluster_ward_on_supervoxels_cpp', PACKAGE = 'neurocluster', X_coarse, G_coarse, sizes, n_clusters)
}

compute_scores <- function(curclus, coords, data_centroids, coord_centroids, data, sigma1, sigma2) {
    .Call('_neurocluster_compute_scores', PACKAGE = 'neurocluster', curclus, coords, data_centroids, coord_centroids, data, sigma1, sigma2)
}

best_candidate <- function(candidates, curclus, coords, data_centroids, coord_centroids, data, sigma1, sigma2, alpha) {
    .Call('_neurocluster_best_candidate', PACKAGE = 'neurocluster', candidates, curclus, coords, data_centroids, coord_centroids, data, sigma1, sigma2, alpha)
}

find_candidates <- function(nn_index, nn_dist, curclus, dthresh) {
    .Call('_neurocluster_find_candidates', PACKAGE = 'neurocluster', nn_index, nn_dist, curclus, dthresh)
}

best_candidate_parallel <- function(candidates, curclus, coords, data_centroids, coord_centroids, data, sigma1, sigma2, alpha, grain_size = 100L) {
    .Call('_neurocluster_best_candidate_parallel', PACKAGE = 'neurocluster', candidates, curclus, coords, data_centroids, coord_centroids, data, sigma1, sigma2, alpha, grain_size)
}

best_candidate_sequential <- function(candidates, curclus, coords, data_centroids, coord_centroids, data, sigma1, sigma2, alpha) {
    .Call('_neurocluster_best_candidate_sequential', PACKAGE = 'neurocluster', candidates, curclus, coords, data_centroids, coord_centroids, data, sigma1, sigma2, alpha)
}

heat_kernel <- function(x1, x2, sigma) {
    .Call('_neurocluster_heat_kernel', PACKAGE = 'neurocluster', x1, x2, sigma)
}

normalized_heat_kernel <- function(x1, x2, sigma) {
    .Call('_neurocluster_normalized_heat_kernel', PACKAGE = 'neurocluster', x1, x2, sigma)
}

flash3d_supervoxels_cpp <- function(ts, mask_lin0, dims, K, lambda, rounds = 2L, bits = 64L, dctM = 12L, vox_scale = as.numeric( c(1.0,1.0,1.0)), barrier_opt = NULL, verbose = FALSE) {
    .Call('_neurocluster_flash3d_supervoxels_cpp', PACKAGE = 'neurocluster', ts, mask_lin0, dims, K, lambda, rounds, bits, dctM, vox_scale, barrier_opt, verbose)
}

fused_assignment <- function(nn_index, nn_dist, curclus, coords, data_centroids, coord_centroids, data, dthresh, sigma1, sigma2, alpha) {
    .Call('_neurocluster_fused_assignment', PACKAGE = 'neurocluster', nn_index, nn_dist, curclus, coords, data_centroids, coord_centroids, data, dthresh, sigma1, sigma2, alpha)
}

fused_assignment_parallel <- function(nn_index, nn_dist, curclus, coords, data_centroids, coord_centroids, data, dthresh, sigma1, sigma2, alpha, grain_size = 100L) {
    .Call('_neurocluster_fused_assignment_parallel', PACKAGE = 'neurocluster', nn_index, nn_dist, curclus, coords, data_centroids, coord_centroids, data, dthresh, sigma1, sigma2, alpha, grain_size)
}

compute_centroids_parallel <- function(cluster_ids, data, coords, n_clusters, grain_size = 10L) {
    .Call('_neurocluster_compute_centroids_parallel', PACKAGE = 'neurocluster', cluster_ids, data, coords, n_clusters, grain_size)
}

fused_assignment_parallel_binned <- function(nn_index, nn_dist, curclus, coords, data_centroids, coord_centroids, data, dthresh, sigma1, sigma2, alpha, grain_size = 2048L, window_factor = 2.0, bin_expand = 1L) {
    .Call('_neurocluster_fused_assignment_parallel_binned', PACKAGE = 'neurocluster', nn_index, nn_dist, curclus, coords, data_centroids, coord_centroids, data, dthresh, sigma1, sigma2, alpha, grain_size, window_factor, bin_expand)
}

fused_assignment_binned <- function(nn_index, nn_dist, curclus, coords, data_centroids, coord_centroids, data, dthresh, sigma1, sigma2, alpha, window_factor = 2.0, bin_expand = 1L) {
    .Call('_neurocluster_fused_assignment_binned', PACKAGE = 'neurocluster', nn_index, nn_dist, curclus, coords, data_centroids, coord_centroids, data, dthresh, sigma1, sigma2, alpha, window_factor, bin_expand)
}

calculate_local_gradient <- function(feature_mat, neighbor_indices) {
    .Call('_neurocluster_calculate_local_gradient', PACKAGE = 'neurocluster', feature_mat, neighbor_indices)
}

g3s_propagate_cpp <- function(feature_mat, coords, seed_indices, neighbor_indices, neighbor_dists, alpha, compactness) {
    .Call('_neurocluster_g3s_propagate_cpp', PACKAGE = 'neurocluster', feature_mat, coords, seed_indices, neighbor_indices, neighbor_dists, alpha, compactness)
}

refine_boundaries_g3s_cpp <- function(labels, feature_mat, neighbor_indices, max_iter) {
    .Call('_neurocluster_refine_boundaries_g3s_cpp', PACKAGE = 'neurocluster', labels, feature_mat, neighbor_indices, max_iter)
}

#' Compute masked distances for ReNA
#'
#' Computes squared Euclidean distances only for connected pairs in sparse adjacency.
#'
#' @param feature_mat Numeric matrix (features x voxels)
#' @param adjacency_i Integer vector of row indices for sparse adjacency
#' @param adjacency_j Integer vector of col indices for sparse adjacency
#' @return NumericVector of distances (same length as adjacency_i)
#'
#' @keywords internal
compute_masked_distances_cpp <- function(feature_mat, adjacency_i, adjacency_j) {
    .Call('_neurocluster_compute_masked_distances_cpp', PACKAGE = 'neurocluster', feature_mat, adjacency_i, adjacency_j)
}

#' Find 1-Nearest Neighbor subgraph for ReNA
#'
#' For each node, finds its single nearest neighbor to form directed 1-NN graph.
#'
#' @param n_nodes Number of nodes
#' @param adjacency_i Integer vector of row indices for sparse adjacency
#' @param adjacency_j Integer vector of col indices for sparse adjacency
#' @param distances Numeric vector of distances for each edge
#' @return IntegerVector of nearest neighbor indices (0-based, -1 if no neighbors)
#'
#' @keywords internal
find_1nn_subgraph_cpp <- function(n_nodes, adjacency_i, adjacency_j, distances) {
    .Call('_neurocluster_find_1nn_subgraph_cpp', PACKAGE = 'neurocluster', n_nodes, adjacency_i, adjacency_j, distances)
}

#' Find connected components using Union-Find
#'
#' Finds weakly connected components in a directed graph defined by 1-NN edges.
#'
#' @param n_nodes Number of nodes
#' @param nearest_neighbor IntegerVector of nearest neighbor for each node (0-based)
#' @return IntegerVector of component labels (0-based, contiguous)
#'
#' @keywords internal
find_connected_components_cpp <- function(n_nodes, nearest_neighbor) {
    .Call('_neurocluster_find_connected_components_cpp', PACKAGE = 'neurocluster', n_nodes, nearest_neighbor)
}

#' Aggregate features by component (mean pooling)
#'
#' Computes mean feature vector for each component efficiently.
#'
#' @param feature_mat Numeric matrix (features x voxels)
#' @param component_labels IntegerVector of component labels (0-based)
#' @param n_components Number of unique components
#' @return NumericMatrix of aggregated features (features x n_components)
#'
#' @keywords internal
aggregate_features_cpp <- function(feature_mat, component_labels, n_components) {
    .Call('_neurocluster_aggregate_features_cpp', PACKAGE = 'neurocluster', feature_mat, component_labels, n_components)
}

#' Aggregate coordinates by component (mean pooling)
#'
#' Computes mean coordinate for each component efficiently.
#'
#' @param coords Numeric matrix (voxels x 3)
#' @param component_labels IntegerVector of component labels (0-based)
#' @param n_components Number of unique components
#' @return NumericMatrix of aggregated coordinates (n_components x 3)
#'
#' @keywords internal
aggregate_coords_cpp <- function(coords, component_labels, n_components) {
    .Call('_neurocluster_aggregate_coords_cpp', PACKAGE = 'neurocluster', coords, component_labels, n_components)
}

#' Contract adjacency graph by merging components
#'
#' Builds new adjacency matrix where nodes are components and edges exist if
#' any constituent nodes were connected.
#'
#' @param adjacency_i Integer vector of row indices for sparse adjacency
#' @param adjacency_j Integer vector of col indices for sparse adjacency
#' @param component_labels IntegerVector of component labels (0-based)
#' @param n_components Number of unique components
#' @return List with contracted_i and contracted_j vectors
#'
#' @keywords internal
contract_graph_cpp <- function(adjacency_i, adjacency_j, component_labels, n_components) {
    .Call('_neurocluster_contract_graph_cpp', PACKAGE = 'neurocluster', adjacency_i, adjacency_j, component_labels, n_components)
}

#' Prune 1-NN edges to achieve target number of components
#'
#' Sorts 1-NN edges by distance and adds them incrementally until K components remain.
#' Used for exact-K stopping condition.
#'
#' @param n_nodes Number of nodes
#' @param nearest_neighbor IntegerVector of nearest neighbor for each node (0-based)
#' @param distances NumericVector of distances to nearest neighbors
#' @param target_k Target number of components
#' @return IntegerVector of pruned nearest neighbors (-1 for pruned edges)
#'
#' @keywords internal
prune_edges_for_k_cpp <- function(n_nodes, nearest_neighbor, distances, target_k) {
    .Call('_neurocluster_prune_edges_for_k_cpp', PACKAGE = 'neurocluster', n_nodes, nearest_neighbor, distances, target_k)
}

slic4d_core <- function(feats, coords, mask_lin_idx, dims, voxmm, K, compactness = 10.0, max_iter = 10L, step_mm = 0.0, n_threads = 0L, seed_method = "mask_poisson", enforce_connectivity = TRUE, min_size = 0L, connectivity = 26L, strict_connectivity = TRUE, preserve_k = FALSE, topup_iters = 2L, grad_masked = numeric(), seed_relocate_radius = 1L, verbose = FALSE) {
    .Call('_neurocluster_slic4d_core', PACKAGE = 'neurocluster', feats, coords, mask_lin_idx, dims, voxmm, K, compactness, max_iter, step_mm, n_threads, seed_method, enforce_connectivity, min_size, connectivity, strict_connectivity, preserve_k, topup_iters, grad_masked, seed_relocate_radius, verbose)
}

slice_msf_runwise <- function(TS, mask, vol_dim, r = 12L, fh_scale = 0.32, min_size = 80L, nbhd = 8L, stitch_z = FALSE, theta_link = 0.85, min_contact = 1L, rows_are_time = TRUE, gamma = 1.5, voxel_dim = NULL, spatial_beta = 0.0, target_k_global = -1L, target_k_per_slice = -1L, z_mult = 0.0) {
    .Call('_neurocluster_slice_msf_runwise', PACKAGE = 'neurocluster', TS, mask, vol_dim, r, fh_scale, min_size, nbhd, stitch_z, theta_link, min_contact, rows_are_time, gamma, voxel_dim, spatial_beta, target_k_global, target_k_per_slice, z_mult)
}

slice_fuse_consensus <- function(run_results, vol_dim, nbhd = 8L, fh_scale = 0.30, min_size = 80L, use_features = FALSE, lambda = 0.7, voxel_dim = NULL, spatial_beta = 0.0, target_k_global = -1L, target_k_per_slice = -1L, stitch_z = FALSE) {
    .Call('_neurocluster_slice_fuse_consensus', PACKAGE = 'neurocluster', run_results, vol_dim, nbhd, fh_scale, min_size, use_features, lambda, voxel_dim, spatial_beta, target_k_global, target_k_per_slice, stitch_z)
}

update_centroid_online <- function(centroid, x_i, c_i) {
    .Call('_neurocluster_update_centroid_online', PACKAGE = 'neurocluster', centroid, x_i, c_i)
}

snic_main <- function(L_data, mask, centroids, centroid_idx, valid_coords, norm_coords, vecmat, K, s, compactness, mask_lookup_data) {
    .Call('_neurocluster_snic_main', PACKAGE = 'neurocluster', L_data, mask, centroids, centroid_idx, valid_coords, norm_coords, vecmat, K, s, compactness, mask_lookup_data)
}

snic_main_optimized <- function(L_data, mask, centroids, centroid_idx, valid_coords, norm_coords, vecmat, K, s, compactness, mask_lookup_data) {
    .Call('_neurocluster_snic_main_optimized', PACKAGE = 'neurocluster', L_data, mask, centroids, centroid_idx, valid_coords, norm_coords, vecmat, K, s, compactness, mask_lookup_data)
}

compute_boundaryscore_3d_cpp <- function(volume, mask) {
    .Call('_neurocluster_compute_boundaryscore_3d_cpp', PACKAGE = 'neurocluster', volume, mask)
}

detect_boundaries_2d_cpp <- function(volume, mask) {
    .Call('_neurocluster_detect_boundaries_2d_cpp', PACKAGE = 'neurocluster', volume, mask)
}

