---
title: Compare clustering methods
name: compare-methods
description: Run multiple methods on the same data and compare outputs.
output:
  rmarkdown::html_vignette:
    toc: yes
    toc_depth: 2
params:
  family: lapis
  base_size: 13
  content_width: 72
vignette: |
  %\VignetteIndexEntry{Compare clustering methods} %\VignetteEngine{knitr::rmarkdown} %\VignetteEncoding{UTF-8}
css: albers.css
resource_files:
- albers.css
- albers.js
includes:
  in_header: |-
    <link rel="stylesheet" href="albers.css" />
    <script src="albers.js"></script>
    <script>document.addEventListener('DOMContentLoaded',()=>document.body.classList.add('palette-red'));</script>

---

```{r setup, include=FALSE}
if (requireNamespace("ggplot2", quietly = TRUE) && requireNamespace("albersdown", quietly = TRUE)) ggplot2::theme_set(albersdown::theme_albers(params$family))
if (requireNamespace("ggplot2", quietly = TRUE) && requireNamespace("albersdown", quietly = TRUE)) ggplot2::theme_set(albersdown::theme_albers(params$family))
if (requireNamespace("albersdown", quietly = TRUE)) ggplot2::theme_set(albersdown::theme_albers(params$family))
knitr::opts_chunk$set(
  collapse = TRUE, comment = "#>", fig.align = "center", fig.retina = 2,
  out.width = "100%", fig.width = 7, fig.asp = 0.618,
  message = FALSE, warning = FALSE
)
set.seed(123); options(pillar.sigfig = 7, width = 80)
suppressWarnings(suppressPackageStartupMessages({
  library(neurocluster)
  library(neuroim2)
}))
if (requireNamespace("albersdown", quietly = TRUE) && requireNamespace("ggplot2", quietly = TRUE)) {
  ggplot2::theme_set(albersdown::theme_albers(params$family, base_size = params$base_size))
}
if (file.exists("albers.css")) {
  cat(sprintf("<style>\n%s\n</style>", paste(readLines("albers.css", warn = FALSE), collapse = "\n")))
}
cat(sprintf('<script>document.addEventListener("DOMContentLoaded",function(){document.body.classList.add("palette-%s");});</script>', params$family))
cat(sprintf('<style>:root{--content:%sch}</style>', params$content_width))
toy <- make_block_synthetic(dims = c(12, 12, 1), ntime = 60, noise = 0.1, seed = 2025)
```

```{r albers_inject, echo=FALSE, results='asis'}
if (file.exists("albers.css")) {
  cat(sprintf("<style>\n%s\n</style>", paste(readLines("albers.css", warn = FALSE), collapse = "\n")))
}
cat(sprintf('<script>document.addEventListener("DOMContentLoaded",function(){document.body.classList.add("palette-%s");});</script>', params$family))
cat(sprintf('<style>:root{--content:%sch}</style>', params$content_width))
```

# Goal {#goal}
Run several methods with the same `n_clusters` and compare basic characteristics.

We use a simple, scikit-learn-style synthetic (three vertical bands with distinct
time courses plus light noise). Itâ€™s small, deterministic, and spatially local, so
all methods have a fair shot.

# Ground truth bands (for reference) {#fig-toy-ground-truth}
```{r fig-toy-ground-truth, fig.cap='Ground truth bands (3 clusters) on the toy axial slice.', fig.alt='Axial slice showing three colored vertical bands.'}
# Display the ground truth as a simple image
truth_array <- array(toy$truth, dim = toy$dims)
image(truth_array[,,1], col = rainbow(6),
      main = "Ground Truth: 3 bands", axes = FALSE)
```

# Run methods (same K) {#run-methods}
```r
methods <- c("snic", "slice_msf", "supervoxels")
run_one <- function(m) {
  args <- list(vec = toy$vec, mask = toy$mask, n_clusters = 3, method = m)
  if (m == "snic") {
    args$compactness <- 3
    args$max_iterations <- 5
  } else if (m == "slice_msf") {
    args$r <- 8
    args$min_size <- 5
    args$compactness <- 3
    args$num_runs <- 1
    args$stitch_z <- FALSE
  } else if (m == "supervoxels") {
    args$alpha <- 0.6
    args$connectivity <- 6
  }
  out <- try(do.call(cluster4d, args), silent = TRUE)
  if (inherits(out, "try-error")) NULL else out
}
results <- setNames(lapply(methods, run_one), methods)
results_ok <- Filter(Negate(is.null), results)
```

# Axial slices by method {#fig-methods}
```{r fig-methods, fig.cap='Toy axial view clustered by available methods (K=3). Colors indicate cluster IDs (arbitrary).', fig.alt='Panels showing axial slices for available methods with arbitrary cluster colors.'}
# Fallback in case prior chunk failed in a different environment
if (!exists("results_ok", inherits = TRUE)) {
  methods <- c("snic", "slice_msf", "supervoxels")
  run_one <- function(m) {
    # Simple fallback with default parameters
    out <- try(cluster4d(toy$vec, toy$mask,
                         n_clusters = 3, method = m,
                         max_iterations = 5),
               silent = TRUE)
    if (inherits(out, "try-error")) NULL else out
  }
  results <- setNames(lapply(methods, run_one), methods)
  results_ok <- Filter(Negate(is.null), results)
}
n <- length(results_ok); if (n == 0) n <- 1
par(mfrow = c(1, n))
for (nm in names(results_ok)) {
  plot(results_ok[[nm]], slice = c(1, 1, 1), view = "axial")
  title(nm)
}
par(mfrow = c(1, 1))
```

# Compare {#compare}
```r
if (length(results_ok) >= 1) {
  comparison <- do.call(compare_cluster4d, results_ok)
  comparison
}
comparison

# Summarize basic facts from outputs
if (length(results_ok) >= 1) {
  sizes <- lapply(results_ok, function(x) table(x$cluster))
  data.frame(
    method = names(sizes),
    n_clusters = sapply(results_ok, function(x) x$n_clusters),
    min_size = sapply(sizes, min),
    max_size = sapply(sizes, max),
    mean_size = sapply(sizes, function(t) round(mean(t), 1))
  )
}
```

# Notes {#notes}
- SNIC assigns voxels in a single pass via a priority queue (see `snic()`); clusters are connected by construction. Runtime depends on input size and queue operations.
- Supervoxels uses iterative reassignment with spatial/feature kernels (see `supervoxels()`); more iterations can change results and runtime.
- SLIC uses local search windows and can preserve the requested K when `preserve_k = TRUE` (see `cluster4d_slic()`).

# See also {#see-also}
- Validate & compare: articles/validate-compare.html#checks
- Method deep dives: articles/method-deep-dives.html#slic
- Performance & memory: articles/performance-memory.html#scaling
