--- slice_cluster.cpp
+++ slice_cluster_patched.cpp
@@ -126,9 +126,13 @@
 
 inline void build_dct_basis(int T, int r, std::vector<double> &phi) {
   phi.assign(T*r, 0.0);
-  const double s = std::sqrt(2.0 / (double)T);
-  for (int t=0;t<T;++t) for (int k=0;k<r;++k)
-    phi[t*r+k] = s * std::cos(M_PI * ((t+0.5)*(k+1)/(double)T));
+  const double s  = std::sqrt(2.0 / (double)T);
+  const double pi = std::acos(-1.0);
+  for (int t=0; t<T; ++t) {
+    for (int k=0; k<r; ++k) {
+      phi[t*r + k] = s * std::cos(pi * ((t + 0.5) * (k + 1) / (double)T));
+    }
+  }
 }
 
 inline double dot_col(const NumericMatrix &U, int i, int j, int r) {
@@ -161,8 +165,13 @@
   inline void get_ts(int v, std::vector<double> &buf) const {
     buf.assign(T,0.0);
     if (rows_are_time) {
-      const double* col = &TS(0,v);
-      for (int t=0;t<T;++t) buf[t] = col[t];
+      // TS: T x N -> column v is contiguous (column-major)
+      const double* col = &TS(0, v);
+      for (int t=0; t<T; ++t) buf[t] = col[t];
+    } else {
+      // TS: N x T -> row v is NON-contiguous; access element-wise
+      for (int t=0; t<T; ++t) buf[t] = TS(v, t);
+    }
     } else {
       const double* row = &TS(v,0);
       for (int t=0;t<T;++t) buf[t] = row[t];
@@ -274,31 +283,33 @@
   }
 
   // Canonical cleanup: for each small component, merge to its best neighbor
-  // (we allow a couple of passes to catch chains of small components)
-  bool changed = true;
-  int passes = 0;
-  while (changed && passes < 3) {
-    changed = false; passes++;
-    std::vector<float> bestW(ns, std::numeric_limits<float>::infinity());
-    std::vector<int>   bestN(ns, -1);
-
-    for (const auto &e : edges) {
-      int a=uf.find(e.a), b=uf.find(e.b);
-      if (a==b) continue;
-      if (uf.sz[a] < min_size && e.w < bestW[a]) { bestW[a]=e.w; bestN[a]=b; }
-      if (uf.sz[b] < min_size && e.w < bestW[b]) { bestW[b]=e.w; bestN[b]=a; }
-    }
-    for (int v=0; v<ns; ++v) {
-      int a = uf.find(v);
-      if (a!=v) continue;
-      if (uf.sz[a] < min_size && bestN[a] >= 0) {
-        uf.unite(a, bestN[a], bestW[a]);
-        changed = true;
-      }
-    }
-  }
-
-  // Relabel consecutive
+
+  // Canonical cleanup: keep merging undersized components to their best neighbor until none remain
+  {
+    bool changed = true;
+    int iter = 0, max_iter = 32;
+    while (changed && iter++ < max_iter) {
+      changed = false;
+      std::vector<float> bestW(ns, std::numeric_limits<float>::infinity());
+      std::vector<int>   bestN(ns, -1);
+      for (const auto &e : edges) {
+        int a = uf.find(e.a), b = uf.find(e.b);
+        if (a == b) continue;
+        if (uf.sz[a] < min_size && e.w < bestW[a]) { bestW[a] = e.w; bestN[a] = b; }
+        if (uf.sz[b] < min_size && e.w < bestW[b]) { bestW[b] = e.w; bestN[b] = a; }
+      }
+      for (int v = 0; v < ns; ++v) {
+        int a = uf.find(v);
+        if (a != v) continue; // only roots once
+        if (uf.sz[a] < min_size && bestN[a] >= 0) {
+          uf.unite(a, bestN[a], bestW[a]);
+          changed = true;
+        }
+      }
+    }
+  }
+
+Relabel consecutive
   std::unordered_map<int,int> root2lab;
   int lab=1;
   for (int i=0;i<ns;++i) {
@@ -458,6 +469,14 @@
 }
 
 // Per-slice variant: merge within each slice to targetK_per_slice
+
+inline int count_active_roots(int G, UF &uf) {
+  std::unordered_set<int> roots;
+  roots.reserve(G);
+  for (int i=0; i<G; ++i) roots.insert(uf.find(i));
+  return (int)roots.size();
+}
+
 inline void rag_agglomerate_to_K_per_slice(
   const IntegerVector &mask, int nx, int ny, int nz,
   const std::vector<int> &voxel2group, int G, int targetK,
@@ -465,16 +484,57 @@
   NumericMatrix &sumU, std::vector<int> &sz, UF &uf
 ) {
   if (targetK <= 0) return;
-  // For each slice: build adjacency among groups present in that slice only, then merge
   for (int z=0; z<nz; ++z) {
-    // mark groups present in slice
+    // Identify current roots present in this slice
     std::unordered_set<int> present;
-    for (int y=0;y<ny;++y) for (int x=0;x<nx;++x) {
-      int g = idx3d(x,y,z,nx,ny);
-      if (!mask[g]) continue;
-      int grp = voxel2group[g];
-      if (grp>=0) present.insert(grp);
-    }
+    present.reserve(1024);
+    for (int y=0; y<ny; ++y) for (int x=0; x<nx; ++x) {
+      int v = idx3d(x,y,z, nx,ny);
+      if (!mask[v]) continue;
+      int g = voxel2group[v];
+      if (g < 0) continue;
+      present.insert( uf.find(g) );
+    }
+    int S = (int)present.size();
+    if (S <= targetK) continue;
+
+    // Build adjacency among current roots in this slice
+    std::unordered_set<std::pair<int,int>, PairHash> pairs;
+    auto reg_pair = [&](int ra, int rb){
+      if (ra == rb) return;
+      int u = std::min(ra, rb), v = std::max(ra, rb);
+      pairs.emplace(u, v);
+    };
+    for (int y=0; y<ny; ++y) for (int x=0; x<nx; ++x) {
+      int v0 = idx3d(x,y,z, nx,ny);
+      if (!mask[v0]) continue;
+      int g0 = voxel2group[v0]; if (g0 < 0) continue;
+      int r0 = uf.find(g0);
+      // neighbors (forward-only)
+      auto try_nb = [&](int xn, int yn) {
+        int v1 = idx3d(xn, yn, z, nx,ny);
+        if (!mask[v1]) return;
+        int g1 = voxel2group[v1]; if (g1 < 0) return;
+        int r1 = uf.find(g1);
+        reg_pair(r0, r1);
+      };
+      if (x+1 < nx) try_nb(x+1, y);
+      if (y+1 < ny) try_nb(x,   y+1);
+      if (nbhd == 8) {
+        if (x+1 < nx && y+1 < ny) try_nb(x+1, y+1);
+        if (x+1 < nx && y-1 >= 0) try_nb(x+1, y-1);
+      }
+    }
+
+    // Convert per-slice merges to a global target
+    int currentActive = count_active_roots(G, uf);
+    int merges_needed  = S - targetK;
+    int targetGlobal   = std::max(1, currentActive - merges_needed);
+
+    rag_agglomerate_to_K_global(G, targetGlobal, pairs, sumU, sz, uf);
+  }
+}
+
     if ((int)present.size() <= targetK) continue;
 
     std::unordered_set<std::pair<int,int>, PairHash> pairs;
