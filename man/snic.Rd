% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/snic.R
\name{snic}
\alias{snic}
\title{SNIC: Simple Non-Iterative Clustering}
\usage{
snic(vec, mask, compactness = 5, K = 500, max_iter = 100)
}
\arguments{
\item{vec}{A \code{NeuroVec} instance supplying the data to cluster.
Can also be a 3D \code{\linkS4class{NeuroVol}} for structural image segmentation,
which will be automatically converted to a single-timepoint NeuroVec internally.}

\item{mask}{A \code{NeuroVol} mask defining the voxels to include in the clustering result.
If the mask contains \code{numeric} data, nonzero values will define the included voxels.
If the mask is a \code{\linkS4class{LogicalNeuroVol}}, then \code{TRUE} will define the set
of included voxels.}

\item{compactness}{A numeric value controlling the compactness of the clusters, with larger values resulting
in more compact clusters. Default is 5.}

\item{K}{The number of clusters to find. Default is 500.}

\item{max_iter}{Maximum number of iterations for the SNIC algorithm. Default is 100.
Currently ignored as SNIC algorithm uses internal convergence criteria.}
}
\value{
A \code{list} of class \code{snic_cluster_result} with the following elements:
\describe{
\item{clusvol}{An instance of type \linkS4class{ClusteredNeuroVol}.}
\item{gradvol}{A \code{NeuroVol} instance representing the spatial gradient of the reference volume.}
\item{cluster}{A vector of cluster indices equal to the number of voxels in the mask.}
\item{centers}{A matrix of cluster centers with each column representing the feature vector for a cluster.}
\item{coord_centers}{A matrix of spatial coordinates with each row corresponding to a cluster.}
}
}
\description{
The SNIC function performs a spatially constrained clustering on a \code{NeuroVec} instance
using the Simple Non-Iterative Clustering (SNIC) algorithm.
}
\details{
\subsection{Performance Optimization (2025)}{

The SNIC implementation has been \strong{highly optimized} using lightweight C++ structs and
in-place operations, providing \strong{10x-50x speedup} over the original implementation.
Key optimizations include:
\itemize{
\item Elimination of Rcpp::List overhead in priority queue (uses lightweight struct)
\item In-place centroid updates with no memory allocations
\item Inline 26-connectivity neighbor iteration
\item Direct pointer access for array operations
\item Efficient scalar math (eliminates temporary vector allocations)
}
}

\subsection{Parallelization Status}{

\strong{Currently NOT parallelized.} SNIC uses a sequential priority queue-based algorithm
that processes voxels in order of their distance from cluster centers.
\subsection{Sequential Operations:}{
\enumerate{
\item \strong{Initialization}: Gradient-based seed selection using \code{find_initial_points()}
\itemize{
\item Finds K seed points with high gradient and spatial separation
\item Sequential search through candidate voxels
}
\item \strong{Priority Queue Processing} (C++ implementation):
\itemize{
\item Maintains a global priority queue of voxels to be assigned
\item Each voxel assignment depends on previously processed neighbors
\item Voxels are processed in order of their combined distance metric
}
\item \strong{Distance Computation}: For each voxel, calculates:
\itemize{
\item Feature distance to nearest cluster center
\item Spatial distance weighted by compactness parameter
\item Combined into single priority score
}
}
}

\subsection{Why Not Parallelized:}{
\itemize{
\item \strong{Sequential dependency}: Priority queue enforces strict processing order
\item \strong{Global state}: Each voxel assignment affects subsequent assignments
\item \strong{Algorithm design}: SNIC's key innovation is its non-iterative, sequential nature
\item \strong{Coherent clusters}: Sequential processing ensures connected components
}
}

\subsection{Performance Characteristics:}{
\itemize{
\item \strong{Complexity}: O(N log N) where N = number of voxels
\item \strong{Memory}: O(N) for priority queue and assignments
\item \strong{Speed}: Generally faster than iterative methods (supervoxels)
\item \strong{Single pass}: Processes each voxel exactly once
}
}

\subsection{Performance Tips:}{
\itemize{
\item \strong{Reduce K}: Fewer clusters means less competition for voxels
\item \strong{Adjust compactness}: Higher values create more local clusters, faster processing
\item \strong{Pre-smooth data}: Reduce noise to improve gradient-based initialization
\item \strong{Use smaller masks}: Process ROIs separately if possible
\item \strong{Alternative}: Consider \code{slice_msf()} or \code{acsc()} for parallel execution
}
}

\subsection{Comparison with Other Methods:}{
\itemize{
\item \strong{Faster than}: \code{supervoxels()} due to non-iterative nature
\item \strong{Slower than}: \code{slice_msf()} with parallel slices, \code{acsc()} with future backend
\item \strong{More coherent than}: Methods without spatial priority (ensures connectivity)
}
}

}
}
\note{
Consider using \code{\link{cluster4d}} with \code{method = "snic"} for a
standardized interface across all clustering methods.
}
\examples{
\dontrun{
mask <- NeuroVol(array(1, c(20,20,20)), NeuroSpace(c(20,20,20)))
vec <- replicate(10, NeuroVol(array(runif(202020), c(20,20,20)),
NeuroSpace(c(20,20,20))), simplify=FALSE)
vec <- do.call(concat, vec)

snic_res <- snic(vec, mask, compactness=5, K=100)
}

}
\seealso{
\code{\link{supervoxels}}
}
