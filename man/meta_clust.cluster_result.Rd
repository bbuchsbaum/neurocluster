% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/meta_clust.R
\name{meta_clust.cluster_result}
\alias{meta_clust.cluster_result}
\title{Meta Clustering for Cluster Results}
\usage{
\method{meta_clust}{cluster_result}(x, cuts = min(as.integer(length(x$centers)/2), 2), ...)
}
\arguments{
\item{x}{A clustering result, typically an object of class \code{"cluster_result"}.}

\item{cuts}{The number of cluster cuts to consider. Default is the minimum
of half the number of centers and 2.}

\item{...}{Additional arguments:
\describe{
  \item{algo}{A character string indicating the clustering algorithm to use.
              Default is "hclust" (hierarchical clustering).}
  \item{hclust_method}{A character string specifying the agglomeration method
                       to use for hierarchical clustering. Default is "ward.D".}
}}
}
\value{
A list containing:
        \item{cvols}{A list of \code{\linkS4class{ClusteredNeuroVol}} instances.}
        \item{cuts}{The number of cluster cuts.}
        \item{cutmat}{A matrix representing the cluster assignments for each cut.}
        \item{hclus}{The hierarchical clustering result.}
}
\description{
The meta_clust function performs meta clustering on a given clustering result
by applying hierarchical clustering or other clustering algorithms.
}
\details{
## Parallelization Status

**Currently NOT parallelized.** Meta-clustering performs hierarchical clustering
on cluster centers using sequential R functions.

### Sequential Operations:

1. **Distance Matrix Computation**: 
   - Computes correlation distance (1 - cor) between all cluster centers
   - O(K²) pairwise correlations where K = number of input clusters
   - Sequential double loop in base R

2. **Hierarchical Clustering**: `hclust()`
   - Standard hierarchical agglomeration (Ward.D by default)
   - Sequential merging of closest clusters
   - O(K² log K) complexity

3. **Tree Cutting**: `cutree()`
   - Cuts dendrogram at multiple heights
   - Creates nested cluster assignments
   - Linear in number of clusters

### Why Not Parallelized:

- **Small scale**: Usually operates on hundreds of clusters, not thousands of voxels
- **R built-ins**: Uses standard `hclust()` which is sequential
- **Fast enough**: Typically completes in seconds even for large K
- **Memory efficient**: Only stores K×K distance matrix

### Potential for Parallelization:

- Distance matrix computation could use parallel correlation
- Some hierarchical clustering variants support parallelization
- Multiple cuts could be computed in parallel

### Performance Characteristics:

- **Input size**: K clusters from initial clustering (typically 100-1000)
- **Complexity**: O(K²) for distances, O(K² log K) for clustering
- **Memory**: O(K²) for distance matrix
- **Speed**: Usually < 1 second for K < 500

### Performance Tips:

- **Pre-reduce clusters**: Start with fewer initial clusters if meta-clustering is slow
- **Use appropriate linkage**: Ward.D is slower but often gives better results
- **Limit cuts**: Fewer cut levels = faster processing
- **Alternative**: Use consensus clustering (`merge_clus()`) for different approach

### Use Cases:

Meta-clustering is useful for:
- Creating multi-resolution parcellations
- Hierarchical organization of functional regions
- Reducing large numbers of clusters to interpretable groups
- Finding stable cluster boundaries across scales
}
\seealso{
\code{\link[stats]{hclust}}, \code{\link[stats]{cutree}}
}
