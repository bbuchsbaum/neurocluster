% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/acsc.R
\name{acsc}
\alias{acsc}
\title{Adaptive Correlation Superclustering (ACSC)}
\usage{
acsc(
  bvec,
  mask,
  block_size = 2,
  ann_k = 10,
  alpha = 0.5,
  correlation_metric = c("pearson", "spearman", "robust"),
  spatial_weighting = c("gaussian", "binary"),
  refine = TRUE,
  max_refine_iter = 5,
  K = NULL
)
}
\arguments{
\item{bvec}{A NeuroVec-like object containing 4D fMRI data.}

\item{mask}{A NeuroVol-like object (logical or numeric mask).}

\item{block_size}{Approximate side length of blocks (e.g., 2 or 3). Must be > 0.}

\item{ann_k}{Number of approximate (or exact) nearest neighbors per block. Must be >= 1.}

\item{alpha}{Weighting for correlation vs. spatial proximity (0 <= alpha <= 1).}

\item{correlation_metric}{Correlation metric ("pearson", "spearman", "robust").}

\item{spatial_weighting}{Spatial adjacency weighting ("gaussian", "binary").}

\item{refine}{Logical; whether to refine boundaries.}

\item{max_refine_iter}{Maximum iterations for boundary refinement. Must be >= 0.}

\item{K}{(Optional) Desired number of clusters.}
}
\value{
A list with elements:
  \describe{
    \item{cluster_map}{3D array with cluster labels per voxel.}
    \item{graph}{An \code{igraph} object used for clustering.}
    \item{init_block_label}{Initial coarse partition (3D array) matching \code{mask} dimensions.}
  }
}
\description{
Clusters fMRI voxels into spatially-coherent groups based on temporal correlation
and spatial proximity. Includes optional refinement for boundary corrections.
The algorithm supports parallel processing via the future package for improved performance.
}
\details{
## Parallelization Strategy

ACSC uses **user-configurable parallelization via the future package** for several
computationally intensive operations. This allows flexible parallel execution across
different platforms (multicore, cluster, cloud).

### Parallel Operations:

1. **Data Preprocessing** (`future_apply`):
   - Detrending each voxel's time series independently
   - Embarrassingly parallel across voxels
   - Linear speedup with number of workers

2. **Block Summary Computation** (`future_lapply`):
   - Computing mean time series and spatial centroids for each block
   - Parallel across blocks
   - Effective when block_size creates many blocks

3. **Graph Edge Construction** (`future_lapply`):
   - Computing nearest neighbors and edge weights for each block
   - Most computationally intensive parallel operation
   - Near-linear scaling with cores

4. **Cluster Centroid Updates** (`future_lapply`):
   - Recomputing centroids during boundary refinement
   - Parallel across clusters
   - Beneficial for large K values

### Configuring Parallelization:

```r
library(future)

# Sequential (default)
plan(sequential)
result <- acsc(bvec, mask, K = 100)

# Parallel on local machine (uses all cores)
plan(multisession)
result <- acsc(bvec, mask, K = 100)

# Parallel with specific number of workers
plan(multisession, workers = 4)
result <- acsc(bvec, mask, K = 100)

# On a cluster
plan(cluster, workers = c("node1", "node2", "node3"))
result <- acsc(bvec, mask, K = 100)

# Reset to sequential
plan(sequential)
```

### Performance Characteristics:

- **Best speedup**: Graph construction phase (often 60-70% of runtime)
- **Overhead**: Small for detrending, moderate for block operations
- **Memory**: Each worker needs copy of relevant data subset
- **Optimal workers**: Usually matches physical cores (not threads)
- **Break-even point**: Beneficial for masks with >10,000 voxels

### Performance Tips:

- For small datasets (<5,000 voxels), sequential may be faster due to overhead
- Use `plan(multisession)` on Windows/macOS for stability
- Use `plan(multicore)` on Linux for lower memory overhead
- Monitor memory usage with many workers on large datasets
}
