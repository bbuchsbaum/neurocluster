% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/turbo_cluster.R
\name{turbo_cluster}
\alias{turbo_cluster}
\title{turbo_cluster}
\usage{
turbo_cluster(bvec, mask, K = 500, sigma1 = 1, sigma2 = 2.5,
  iterations = 50, connectivity = 27, use_medoid = FALSE, alpha = 0.5,
  filter = c(lp = 0, hp = 0), filter_method = c("bspline", "locfit"),
  sample_frac = 1, nreps = 1, init_with_gradient = FALSE)
}
\arguments{
\item{bvec}{a \code{\linkS4class{NeuroVec}} instance supplying the data to cluster.}

\item{mask}{a \code{\linkS4class{NeuroVol}} mask defining the voxels to include in the clustering result.
If the mask contains \code{numeric} data, nonzero values will define the included voxels. If the mask
is a \code{\linkS4class{LogicalNeuroVol}} then \code{TRUE} will define the set of included voxels.}

\item{K}{the number of clusters to find.}

\item{sigma1}{the bandwidth of the heat kernel for computing similarity of the data vectors.}

\item{sigma2}{the bandwidth of the heat kernel for computing similarity of the coordinate vectors.
If this value is small, then relatively larger weights are given to nearby voxels. If is is large, then
spatial weights will be less salient. A relatively large sigma1/sigma2 ratio weights data features more than
spatial features, whereas as large sigma2/sigma1 ration does the opposite.}

\item{iterations}{the maximum number of cluster iterations}

\item{use_medoid}{whether to use the medoids to define cluster centroids}

\item{filter}{low- and high-pass filter parameters. See details.}
}
\value{
a \code{list} of class \code{turbo_cluster_result} with the following elements:

\describe{
  \item{clustervol}{an instance of type \linkS4class{ClusteredNeuroVol}}
  \item{clusters}{ a vector of cluster indices equal to the number of voxels in the mask}
  \item{centers}{ a matrix of cluster centers with each column representing the feature vector for a cluster }
  \item{coord_centers}{ a matrix of spatial coordinates with each row corresponding to a cluster }
}
}
\description{
Cluster a \code{NeuroVec} instance into a set of spatially constrained clusters.
}
\examples{

mask <- NeuroVol(array(1, c(20,20,20)), NeuroSpace(c(20,20,20)))
bvec <- replicate(10, NeuroVol(array(runif(20*20*20), c(20,20,20)),
NeuroSpace(c(20,20,20))), simplify=FALSE)
bvec <- do.call(concat, bvec)

cres1 <- turbo_cluster(bvec, mask, K=100, sigma1=1, sigma2=10, sample_frac=.3)
cres2 <- turbo_cluster(bvec, mask, K=100, sigma1=1, sigma2=6, sample_frac=.3)
cres3 <- turbo_cluster(bvec, mask, K=100, sigma1=1, sigma2=4, sample_frac=.3)
cres4 <- turbo_cluster(bvec, mask, K=100, sigma1=1, sigma2=2, sample_frac=.3)

cres_cons <- merge_clus(cres1, cres2, cres3, cres4)

cres_cons2 <- turbo_cluster(bvec, mask, K=100, sigma1=c(1,2,3), sigma2=c(3,2,1), sample_frac=.3)

## to access the cluster volume: cres1$clusvol
}
