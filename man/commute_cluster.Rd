% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/commute_cluster.R
\name{commute_cluster}
\alias{commute_cluster}
\title{Commute Time Clustering}
\usage{
commute_cluster(
  bvec,
  mask,
  K = 100,
  ncomp = ceiling(sqrt(K * 2)),
  alpha = 0.5,
  sigma1 = 0.73,
  sigma2 = 5,
  connectivity = 27,
  weight_mode = c("binary", "heat")
)
}
\arguments{
\item{bvec}{A \code{NeuroVec} instance supplying the data to cluster.}

\item{mask}{A \code{NeuroVol} mask defining the voxels to include in the clustering result.
If the mask contains \code{numeric} data, nonzero values will define the included voxels.
If the mask is a \code{\linkS4class{LogicalNeuroVol}}, then \code{TRUE} will define the set
of included voxels.}

\item{K}{The number of clusters to find. Default is 100.}

\item{ncomp}{The number of components to use for the commute time embedding. Default is the ceiling of \code{sqrt(K2)}.}

\item{alpha}{A numeric value controlling the balance between spatial and feature similarity. Default is 0.5.}

\item{sigma1}{A numeric value controlling the spatial weighting function. Default is 0.73.}

\item{sigma2}{A numeric value controlling the feature weighting function. Default is 5.}

\item{connectivity}{An integer representing the number of nearest neighbors to consider when constructing the similarity graph.
Default is 27.}

\item{weight_mode}{A character string indicating the type of weight function for the similarity graph. Options are "binary" and "heat".
Default is "heat".}
}
\value{
A \code{list} of class \code{commute_time_cluster_result} with the following elements:
\describe{
\item{clusvol}{An instance of type \linkS4class{ClusteredNeuroVol}.}
\item{cluster}{A vector of cluster indices equal to the number of voxels in the mask.}
\item{centers}{A matrix of cluster centers with each column representing the feature vector for a cluster.}
\item{coord_centers}{A matrix of spatial coordinates with each row corresponding to a cluster.}
}
}
\description{
The commute_cluster function performs spatially constrained clustering on a \code{NeuroVec} instance
using the commute time distance and K-means clustering.
}
\details{
## Parallelization Status

**Currently NOT parallelized.** The commute_cluster algorithm runs sequentially,
relying on matrix operations from the `neighborweights` package.

### Sequential Operations:

1. **Graph Construction**: `weighted_spatial_adjacency()`
   - Builds weighted adjacency matrix combining spatial and feature similarity
   - Sequential nearest neighbor search
   - Weight computation for each edge

2. **Commute Time Embedding**: `commute_time_distance()`
   - Eigendecomposition of graph Laplacian
   - Computation of commute distances in spectral space
   - Matrix operations potentially use BLAS/LAPACK threading

3. **K-means Clustering**: Standard k-means on embedded coordinates
   - Multiple random starts (sequential)
   - Iterative centroid updates

### Why Not Parallelized:

- **External dependencies**: Uses `neighborweights` package functions
- **Matrix operations**: Relies on optimized BLAS/LAPACK libraries
- **Eigendecomposition**: Difficult to parallelize efficiently in R
- **Small overhead**: Graph construction often not the bottleneck

### Performance Characteristics:

- **Complexity**: O(N³) for eigendecomposition (limiting factor)
- **Memory intensive**: Stores full N×N adjacency matrix
- **Scalability limit**: Practical for up to ~10,000 voxels
- **Numerical stability**: Can fail with singular matrices or perfect correlations

### Indirect Parallelization:

While the R code is sequential, performance can benefit from:
- **Optimized BLAS**: Use OpenBLAS, Intel MKL, or Apple Accelerate
- **Multi-threaded LAPACK**: Eigendecomposition may use multiple threads
- Configure with: `options(matprod = "blas")` or system BLAS settings

### Performance Tips:

- **Reduce connectivity**: Smaller neighborhoods = sparser matrices
- **Increase alpha**: Higher values reduce graph density
- **Use fewer components**: Set ncomp << K for faster embedding
- **Pre-filter voxels**: Remove low-variance voxels before clustering
- **Alternative methods**: For large data, use `slice_msf()` or `acsc()`

### Common Issues:

- **Eigenvalue errors**: Often due to singular matrices from duplicate time series
- **Memory errors**: Full adjacency matrix requires O(N²) memory
- **Slow performance**: Eigendecomposition dominates runtime for large N
}
\examples{
mask <- NeuroVol(array(1, c(20,20,20)), NeuroSpace(c(20,20,20)))
vec <- replicate(10, NeuroVol(array(runif(202020), c(20,20,20)),
NeuroSpace(c(20,20,20))), simplify=FALSE)
vec <- do.call(concat, vec)

commute_res <- commute_cluster(vec, mask, K=100)

}
\seealso{
\code{\link{snic}}
}
