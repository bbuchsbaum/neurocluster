% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/rena.R
\name{rena}
\alias{rena}
\title{Recursive Nearest Agglomeration (ReNA) Clustering}
\usage{
rena(
  bvec,
  mask,
  K = 100,
  connectivity = 26,
  max_iterations = 50,
  verbose = FALSE,
  exact_k = TRUE
)
}
\arguments{
\item{bvec}{A \code{NeuroVec} instance supplying the 4D data to cluster.}

\item{mask}{A \code{NeuroVol} mask defining the voxels to include in clustering.
If numeric, nonzero values define included voxels. If logical, TRUE values
define included voxels.}

\item{K}{The number of clusters to find (default 100).}

\item{connectivity}{Neighborhood connectivity (6 or 26). Default 26.
6 = face neighbors only, 26 = face + edge + corner neighbors.}

\item{max_iterations}{Maximum number of recursion iterations (default 50).
Algorithm stops when K clusters are reached or max_iterations is hit.}

\item{verbose}{Logical; whether to print progress messages. Default FALSE.}

\item{exact_k}{Logical; whether to use edge pruning to ensure exactly K clusters.
Default TRUE. If FALSE, may produce slightly more or fewer than K clusters.}
}
\value{
A \code{list} of class \code{rena_cluster_result} (inheriting from
\code{cluster_result}) with the following elements:
\describe{
\item{clusvol}{An instance of type \linkS4class{ClusteredNeuroVol}.}
\item{cluster}{A vector of cluster indices equal to the number of voxels in the mask.}
\item{centers}{A matrix of cluster centers with each row representing the feature vector for a cluster.}
\item{coord_centers}{A matrix of spatial coordinates with each row corresponding to a cluster.}
\item{n_clusters}{Actual number of clusters found.}
\item{method}{Clustering method used ("rena").}
\item{parameters}{List of all parameters used.}
\item{metadata}{List containing iteration count and convergence information.}
}
}
\description{
Performs spatially-constrained hierarchical clustering using recursive 1-nearest
neighbor aggregation. ReNA is a fast, linear-time agglomerative algorithm that
avoids the "percolation" problem of standard hierarchical methods by using
1-NN graphs to ensure balanced cluster sizes.
}
\details{
\subsection{Algorithm Description}{

ReNA recursively aggregates features using a 1-Nearest Neighbor (1-NN) graph
to ensure clusters remain roughly balanced in size and spatially compact.
The algorithm proceeds in iterations:
\enumerate{
\item \strong{Connectivity Constraint}: Clustering respects the spatial topology graph G.
Distance is only calculated between spatially adjacent voxels.
\item \strong{Similarity Calculation}: For all connected edges, compute squared Euclidean
distance in feature space.
\item \strong{1-NN Subgraph}: For every voxel, identify its single nearest neighbor.
This forms a directed subgraph Q. The 1-NN graph is less likely to "percolate"
(create giant components) compared to k-NN graphs where k >= 2.
\item \strong{Connected Components}: Extract weakly connected components of Q. These
components become the clusters for the current iteration.
\item \strong{Reduction}: Features within each component are averaged to form a single
"super-feature" for the next iteration. The graph G is contracted so edges
between new clusters exist if any constituent voxels were connected.
\item \strong{Stopping Condition}: Repeat recursively until the number of clusters
drops to the desired K. If exact_k = TRUE, edges are pruned by distance
to ensure exactly K clusters.
}
}

\subsection{Performance Characteristics}{
\itemize{
\item \strong{Complexity}: O(N log N) per iteration where N = number of voxels
\item \strong{Memory}: O(N) for graph and assignments
\item \strong{Speed}: Generally faster than iterative methods (supervoxels)
\item \strong{Iterations}: Typically 5-15 iterations to reach K clusters from N voxels
}
}

\subsection{Advantages over Other Methods}{
\itemize{
\item \strong{No percolation}: Unlike single-linkage, doesn't form one giant cluster
\item \strong{Balanced sizes}: 1-NN graph encourages roughly equal cluster sizes
\item \strong{Topology-aware}: Respects spatial structure via connectivity graph
\item \strong{Deterministic}: No random initialization
\item \strong{Fast convergence}: Linear-time operations per iteration
}
}

\subsection{Parallelization Status}{

\strong{Currently NOT parallelized.} ReNA uses a sequential recursive algorithm
that processes the graph in a hierarchical manner. Each iteration depends on
the previous iteration's clustering result.
\subsection{Sequential Operations:}{
\enumerate{
\item \strong{Distance Computation}: Pairwise distances for connected voxels (C++)
\item \strong{1-NN Finding}: Each voxel finds its nearest neighbor (C++)
\item \strong{Component Detection}: Union-Find algorithm for connected components (C++)
\item \strong{Feature Aggregation}: Mean pooling within components (C++)
\item \strong{Graph Contraction}: Building reduced graph for next iteration (C++)
}
}

\subsection{Why Not Parallelized:}{
\itemize{
\item \strong{Sequential dependency}: Each iteration requires previous iteration's result
\item \strong{Fast per-iteration}: Linear-time operations make parallelization overhead high
\item \strong{Small iteration count}: Typically 5-15 iterations total
\item \strong{C++ optimization}: Core operations already optimized in C++
}
}

\subsection{Performance Tips:}{
\itemize{
\item \strong{Reduce connectivity}: Use connectivity=6 instead of 26 for larger graphs
\item \strong{Use smaller K}: Fewer target clusters means fewer iterations
\item \strong{Pre-smooth data}: Reduces noise, improves cluster coherence
\item \strong{Alternative for parallelism}: Consider \code{slice_msf()} or \code{flash3d()}
}
}

}
}
\note{
Consider using \code{\link{cluster4d}} with \code{method = "rena"} for a
standardized interface across all clustering methods.
}
\examples{
\dontrun{
# Small synthetic example
library(neuroim2)
mask <- NeuroVol(array(1, c(10,10,10)), NeuroSpace(c(10,10,10)))
vec <- replicate(20,
                 NeuroVol(array(runif(10*10*10), c(10,10,10)),
                          NeuroSpace(c(10,10,10))),
                 simplify=FALSE)
vec <- do.call(concat, vec)

# Run ReNA clustering
rena_res <- rena(vec, mask, K=50, connectivity=26)
print(rena_res$n_clusters)

# With verbose output
rena_res <- rena(vec, mask, K=50, verbose=TRUE)
}

}
\references{
Hoyos-Idrobo, A., Varoquaux, G., Kahn, J., & Thirion, B. (2019).
Recursive Nearest Agglomeration (ReNA): Fast clustering for approximation
of structured signals. \emph{Pattern Recognition}, 94, 17-28.
}
\seealso{
\code{\link{cluster4d}} for unified interface,
\code{\link{supervoxels}} for iterative heat kernel clustering,
\code{\link{snic}} for non-iterative priority queue clustering
}
